<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>LCA Hext Extraction UI</title>
    <style>
.autoscrape-over {
  border: 3px solid red;
}
.autoscrape-selected {
  border: 3px solid lightgreen !important;
}
.autoscrape-selected-parent {
  padding: 3px !important;
  margin: 3px !important;
  border: 3px solid yellow !important;
  outline-style: solid !important;
  outline-color: yellow !important;
}

#autoscrape-extractor-ui #autoscrape-controls {
  position: fixed;
  top: 0;
  height: 50px;
}

#autoscrape-extractor-ui button {
  display: inline-block;
}

#autoscrape-extractor-ui #hext-template {
  margin-top: 10px;
}

#autoscrape-extractor-ui #main {
  margin-top: 50px;
}

#autoscrape-extractor-ui #hext-template-copyable {
  height: 50px;
  width: 300px;
}

#hext-template .hidden {
  visibility: hidden !important;
}
    </style>
  </head>

  <body>
    <div id="autoscrape-extractor-ui">
      <div id="autoscrape-controls">
        <button id="prev">Prev HTML Document</button>
        <button id="next">Next HTML Document</button>
        <button id="complete">Create Template</button>
        <div id="hext-template">
          <textarea id="hext-template-copyable" class="hidden"></textarea>
        </div>
      </div>
      <div id="main"></div>
    </div>

    <script
         src="https://code.jquery.com/jquery-2.2.4.min.js"
         integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
         crossorigin="anonymous"></script>
    <script>
const selectedClass = "autoscrape-selected";
const selectedParentClass = "autoscrape-selected-parent";
// NOTE: if overClass changes, change the regex replacement
// on the HTML chunk below (bottom of runUI method)
const overClass = "autoscrape-over";
// save our LCA HTML chunk here (HACK)
let LCA = null;

/**
 * Get the absolute depth of a element, from its target
 * property. This doesn't differentiate between equal depth
 * nodes from different branches.
 */
const getDepth = (target) => {
  let parent = target.parentNode;
  let depth = 0;
  while (parent !== null) {
    depth++;
    parent = parent.parentNode;
  }
  return depth;
};

/**
 * Get the lowest common ancestor (LCA), as an Element, of a
 * set of element nodes. Note that this is *not* an optimal
 * LCA algorithm.
 */
const getLCA = (nodes) => {
  const depthNodes = {};
  let lowest = null;

  if (nodes.length === 1) {
    return nodes[0].target.parentNode;
  }

  // get the depth of each node
  console.log("Finding depths");
  for (const nodeIx in nodes) {
    const node = nodes[nodeIx];
    const depth = getDepth(node.target);
    if (depthNodes[depth] === undefined) {
      depthNodes[depth] = [];
    }
    depthNodes[depth].push(node);
    if (lowest === null || lowest > depth) {
      lowest = depth;
    }
    console.log("nodeIx", nodeIx, "depth", depth);
  }

  // find the parent node of each depth node and
  // loop until every node has a parent node of
  // the same height
  console.log("Finding depth parents");
  let eqDepthParents = [];
  for (const depth in depthNodes) {
    for (const nIx in depthNodes[depth]) {
      let parentNode = depthNodes[depth][nIx].target.parentNode;
      if (depth == lowest) {
        eqDepthParents.push(parentNode);
      }
      else {
        let i = depth;
        for (; i > lowest; i--) {
          console.log("crawling. i", i);
          parentNode = parentNode.parentNode;
        }
        eqDepthParents.push(parentNode);
      }
      console.log("depth", depth, "nIx", nIx);
    }
  }

  // now that all the nodes have a parent of the same height,
  // check to see if the common-height parent is the
  // same parent for all, if yes, return it
  // if it's not, go up another level and see if those
  // are all the same, continue until this it true
  let pDepth = lowest;
  console.log("Checking common parent depth");
  while (pDepth > 0) {
    const allEqual = eqDepthParents.every((v, i, a) => {
      console.log("checking eq", v, i, a);
      return v === a[0];
    });
    console.log("allEqual", allEqual, "eqDepthParents", eqDepthParents);
    console.log();
    if (allEqual) {
      console.log("All equal, returning", eqDepthParents[0]);
      return eqDepthParents[0];
    }
    pDepth--;
    const nextParents = [];
    for (nIx in eqDepthParents) {
      const node = eqDepthParents[nIx];
      nextParents.push(node.parentNode);
    }
    eqDepthParents = nextParents;
  }

  // we found no solution!
  return null;
};

/**
 * Set up the mouse over and clicking functionality
 * along with the highlighting of the LCA.
 */
const runUI = () => {
  // clear the chunk display
  // $("#lca-html").text("").html();
  $("#hext-template-copyable").val("");
  $("#hext-template-copyable").addClass("hidden");

  // grab all HTML document's elements
  const els = $("#main").find("*");
  let selectedEls = [];
  let parentNode = null;

  // we need both enter/leave and over/out pairs
  // for this to work correctly with nested nodes
  els.on("mouseenter mouseover", (e) => {
    e.stopPropagation();
    $(e.target).addClass(overClass);
  });
  els.on("mouseleave mouseout", (e) => {
    e.stopPropagation();
    $(e.target).removeClass(overClass);
  });

  // when we click, add the node to our node list
  // and also outline it
  els.on("click", (e) => {
    // don't propogate click upwards
    e.preventDefault()
    e.stopPropagation();

    // add to selected
    const selIx = selectedEls.indexOf(e);
    if(selIx === -1) {
      $(e.target).addClass(selectedClass);
      selectedEls.push(e);
    }
    // remove from selected
    else {
      $(e.target).removeClass(selectedClass);
      selectedEls.splice(selIx, 1);
    }

    // highlight parent element if we have some nodes
    const lca = getLCA(selectedEls);
    $("*").removeClass(selectedParentClass);
    $(lca).addClass(selectedParentClass);

    // this really shouldn't happen anymore. but we have
    // to recover from the possibility somehow
    if (!lca) {
      $("*").removeClass(selectedParentClass);
      $("*").removeClass(selectedClass);
      selectedEls = [];
    }
    // we have an LCA, grab the outerHTML and display the chunk
    else {
      // NOTE: if overClass changes, this needs to change
      const chunk = lca.outerHTML.replace(/\s*autoscrape-over\s*/, " ");
      // $("#lca-html").text(chunk).html();
      LCA = chunk;
    }
  });
};

/**
 * Cancel all handlers and freeze the HTML chunk.
 */
const stopUI = () => {
  const els = $("#main").find("*");
  els.removeClass(overClass);
  els.off();
  els.on("click", (e) => {
    e.preventDefault()
    e.stopPropagation();
  });
  $("#complete").hide();
};

/**
 * Convert an HTML chunk, with selected classes attached, into
 * a hext template where the selected nodes are extracted.
 */
const html2hext = (html) => {
  console.log("html2hext", html);
  const parsed = $.parseHTML(html);
  console.log("parsed", parsed);
  if (parsed.length !== 1) {
    console.error("Cannot build a Hext template without a single root node");
    return;
  }
  const root = parsed[0];

  let output = "";

  /**
   * Recursive plan:
   * 1) check if element has selected class
   *   a) yes: build a @text:COL[N], href if a, src if img
   * 2) remove all attributes from element
   * 3) check for children nodes
   *   a) yes:
   *     i) write opening tag w/ optional extractor
   *     ii) recurse into children node in a loop
   *     iii) write closing tag
   *   b) no: write full tag w/ optional extractor
   */
  let colN = 1;
  const transform = (node) => {
    if (!node) {
      console.error("No node", node);
      return;
    }
    console.log("transform node", node, "output", output);
    window.N = node;
    // build selector
    let selectors = [];
    if (node.classList.contains(selectedClass)) {
      selectors.push(`@text:COLUMN-${colN++}`);
      switch (node.tagName) {
        case "IMG":
          if (node.getAttribute("src")) {
            selectors.push(`src:COLUMN-${colN++}`);
          }
          break;
        case "A":
          if (node.getAttribute("href")) {
            selectors.push(`href:COLUMN-${colN++}`);
          }
          break;
        default:
          break;
      }
    }

    const selectorStr = selectors.join(" ");

    // remove attributes
    for (let i in node.attributes) {
      if (node.hasOwnProperty(i)) {
        const name = node.attributes[i].name;
        console.log("remove attrib", name);
        node.removeAttribute(name);
      }
    }

    console.log("selectors", selectors, "tag", node.tagName);

    let children = node.children;
    console.log("children", children);
    if (children.length === 0) {
      // write opening & closing tag w/ selectors
      output += `<${node.tagName} ${selectorStr} />`;
      console.log("no children. output", output);
    }
    else {
      // write opening tag w/ selectors
      output += `<${node.tagName} ${selectorStr}>`;
      console.log("children. output", output);
      for (const i in children) {
        if (children.hasOwnProperty(i)) {
          const child = children[i];
          console.log("child", child);
          transform(child, output);
        }
      }
      // write closing tag
      output += `</${node.tagName}>`;
    }

  };

  transform(root);
  return output;
};

const resize = (size) => {
  console.log("resizing", size);
  window.parent.postMessage({
    from: 'outputIframe',
    type: 'resize',
    wfModuleId: parseInt(/(\d+)\/output/.exec(String(window.location))[1], 10),
    height: size,
  }, window.location.origin)
};

const sendHextUpwards = (hext) => {
  window.parent.postMessage({
    from: 'outputIframe',
    type: 'set-params',
    params: {
      hext_template: hext
    },
    wfModuleId: parseInt(/(\d+)\/output/.exec(String(window.location))[1], 10),
  }, window.location.origin)
};

/**
 * TODO: remove iframe, link, style, script
 * TODO: remove all event listeners before adding any
 * of our own here.
 * TODO: go through all links and remove/replace the href?
 * this will mess with the DOM though and would break the
 * Hext template.
 *
 * I have done this manually in the HTML document, but we
 * need to think about potential security problems here
 * w.r.t. loading arbitarty HTML and rendering it.
 */

let docIx = 0;

const dataReady = (data) => {
  console.log("dataReady", data);
  $("#complete").hide();
  $("#main").html("");
  $("#main").html(data.html[docIx++ % data.html.length]);
  $("#complete").show();
  runUI();
  $("#complete").on("click", () => {
    $("#complete").hide();
    stopUI();
    const hext = html2hext(LCA.replace("\n", "").trim());
    console.log("Hext", hext);
    $("#hext-template-copyable").val(hext);
    $("#hext-template textarea").removeClass("hidden");
    sendHextUpwards(hext);
  });
};

const startLoading = (d) => {
  const url = String(window.location).replace(/\/output.*/, '/embeddata')
  fetch(url, { credentials: 'same-origin' })
    .then((response) => {
      if (!response.ok) {
        throw new Error('Invalid response code: ' + response.status)
      }
      return response.json()
    })
    .then((data) => {
      console.log("data", data);
      if (!data.html) {
        console.log("Hiding this whole thing");
        resize(0);
      }
      else {
        console.log("json data", data);
        $("#prev").on("click", dataReady.bind(this, data));
        $("#next").on("click", dataReady.bind(this, data));
        resize(500);
        dataReady(data);
      }
    })
    .catch(console.error)
};

window.addEventListener('hashchange', startLoading);
startLoading();

    </script>
  </body>

</html>
